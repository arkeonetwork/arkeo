// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: arkeo/arkeo/keeper.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	github_com_arkeonetwork_arkeo_common "github.com/arkeonetwork/arkeo/common"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ProviderStatus defines the possible status values for a provider.
type ProviderStatus int32

const (
	// OFFLINE indicates the provider is offline.
	ProviderStatus_OFFLINE ProviderStatus = 0
	// ONLINE indicates the provider is online.
	ProviderStatus_ONLINE ProviderStatus = 1
)

var ProviderStatus_name = map[int32]string{
	0: "OFFLINE",
	1: "ONLINE",
}

var ProviderStatus_value = map[string]int32{
	"OFFLINE": 0,
	"ONLINE":  1,
}

func (x ProviderStatus) String() string {
	return proto.EnumName(ProviderStatus_name, int32(x))
}

func (ProviderStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f833050061122841, []int{0}
}

// ContractType defines the type of contract.
type ContractType int32

const (
	// SUBSCRIPTION is a subscription contract.
	ContractType_SUBSCRIPTION ContractType = 0
	// PAY_AS_YOU_GO is a pay-as-you-go contract.
	ContractType_PAY_AS_YOU_GO ContractType = 1
)

var ContractType_name = map[int32]string{
	0: "SUBSCRIPTION",
	1: "PAY_AS_YOU_GO",
}

var ContractType_value = map[string]int32{
	"SUBSCRIPTION":  0,
	"PAY_AS_YOU_GO": 1,
}

func (x ContractType) String() string {
	return proto.EnumName(ContractType_name, int32(x))
}

func (ContractType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f833050061122841, []int{1}
}

// ContractAuthorization defines contract authorization options.
type ContractAuthorization int32

const (
	// STRICT means strict authorization.
	ContractAuthorization_STRICT ContractAuthorization = 0
	// OPEN means open authorization.
	ContractAuthorization_OPEN ContractAuthorization = 1
)

var ContractAuthorization_name = map[int32]string{
	0: "STRICT",
	1: "OPEN",
}

var ContractAuthorization_value = map[string]int32{
	"STRICT": 0,
	"OPEN":   1,
}

func (x ContractAuthorization) String() string {
	return proto.EnumName(ContractAuthorization_name, int32(x))
}

func (ContractAuthorization) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f833050061122841, []int{2}
}

// ProviderStatus defines the status of a provider.
type Provider struct {
	PubKey              github_com_arkeonetwork_arkeo_common.PubKey  `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3,casttype=github.com/arkeonetwork/arkeo/common.PubKey" json:"pub_key,omitempty"`
	Service             github_com_arkeonetwork_arkeo_common.Service `protobuf:"varint,2,opt,name=service,proto3,casttype=github.com/arkeonetwork/arkeo/common.Service" json:"service,omitempty"`
	MetadataUri         string                                       `protobuf:"bytes,3,opt,name=metadata_uri,json=metadataUri,proto3" json:"metadata_uri,omitempty"`
	MetadataNonce       uint64                                       `protobuf:"varint,4,opt,name=metadata_nonce,json=metadataNonce,proto3" json:"metadata_nonce,omitempty"`
	Status              ProviderStatus                               `protobuf:"varint,5,opt,name=status,proto3,enum=arkeo.arkeo.ProviderStatus" json:"status,omitempty"`
	MinContractDuration int64                                        `protobuf:"varint,6,opt,name=min_contract_duration,json=minContractDuration,proto3" json:"min_contract_duration,omitempty"`
	MaxContractDuration int64                                        `protobuf:"varint,7,opt,name=max_contract_duration,json=maxContractDuration,proto3" json:"max_contract_duration,omitempty"`
	SubscriptionRate    []types.Coin                                 `protobuf:"bytes,8,rep,name=subscription_rate,json=subscriptionRate,proto3" json:"subscription_rate"`
	PayAsYouGoRate      []types.Coin                                 `protobuf:"bytes,9,rep,name=pay_as_you_go_rate,json=payAsYouGoRate,proto3" json:"pay_as_you_go_rate"`
	Bond                cosmossdk_io_math.Int                        `protobuf:"bytes,10,opt,name=bond,proto3,customtype=cosmossdk.io/math.Int" json:"bond"`
	LastUpdate          int64                                        `protobuf:"varint,11,opt,name=last_update,json=lastUpdate,proto3" json:"last_update,omitempty"`
	SettlementDuration  int64                                        `protobuf:"varint,12,opt,name=settlement_duration,json=settlementDuration,proto3" json:"settlement_duration,omitempty"`
}

func (m *Provider) Reset()         { *m = Provider{} }
func (m *Provider) String() string { return proto.CompactTextString(m) }
func (*Provider) ProtoMessage()    {}
func (*Provider) Descriptor() ([]byte, []int) {
	return fileDescriptor_f833050061122841, []int{0}
}
func (m *Provider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Provider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Provider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Provider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Provider.Merge(m, src)
}
func (m *Provider) XXX_Size() int {
	return m.Size()
}
func (m *Provider) XXX_DiscardUnknown() {
	xxx_messageInfo_Provider.DiscardUnknown(m)
}

var xxx_messageInfo_Provider proto.InternalMessageInfo

func (m *Provider) GetPubKey() github_com_arkeonetwork_arkeo_common.PubKey {
	if m != nil {
		return m.PubKey
	}
	return nil
}

func (m *Provider) GetService() github_com_arkeonetwork_arkeo_common.Service {
	if m != nil {
		return m.Service
	}
	return 0
}

func (m *Provider) GetMetadataUri() string {
	if m != nil {
		return m.MetadataUri
	}
	return ""
}

func (m *Provider) GetMetadataNonce() uint64 {
	if m != nil {
		return m.MetadataNonce
	}
	return 0
}

func (m *Provider) GetStatus() ProviderStatus {
	if m != nil {
		return m.Status
	}
	return ProviderStatus_OFFLINE
}

func (m *Provider) GetMinContractDuration() int64 {
	if m != nil {
		return m.MinContractDuration
	}
	return 0
}

func (m *Provider) GetMaxContractDuration() int64 {
	if m != nil {
		return m.MaxContractDuration
	}
	return 0
}

func (m *Provider) GetSubscriptionRate() []types.Coin {
	if m != nil {
		return m.SubscriptionRate
	}
	return nil
}

func (m *Provider) GetPayAsYouGoRate() []types.Coin {
	if m != nil {
		return m.PayAsYouGoRate
	}
	return nil
}

func (m *Provider) GetLastUpdate() int64 {
	if m != nil {
		return m.LastUpdate
	}
	return 0
}

func (m *Provider) GetSettlementDuration() int64 {
	if m != nil {
		return m.SettlementDuration
	}
	return 0
}

// Contract represents a contract between client and provider.
type Contract struct {
	Provider           github_com_arkeonetwork_arkeo_common.PubKey  `protobuf:"bytes,1,opt,name=provider,proto3,casttype=github.com/arkeonetwork/arkeo/common.PubKey" json:"provider,omitempty"`
	Service            github_com_arkeonetwork_arkeo_common.Service `protobuf:"varint,2,opt,name=service,proto3,casttype=github.com/arkeonetwork/arkeo/common.Service" json:"service,omitempty"`
	Client             github_com_arkeonetwork_arkeo_common.PubKey  `protobuf:"bytes,3,opt,name=client,proto3,casttype=github.com/arkeonetwork/arkeo/common.PubKey" json:"client,omitempty"`
	Delegate           github_com_arkeonetwork_arkeo_common.PubKey  `protobuf:"bytes,4,opt,name=delegate,proto3,casttype=github.com/arkeonetwork/arkeo/common.PubKey" json:"delegate,omitempty"`
	Type               ContractType                                 `protobuf:"varint,5,opt,name=type,proto3,enum=arkeo.arkeo.ContractType" json:"type,omitempty"`
	Height             int64                                        `protobuf:"varint,6,opt,name=height,proto3" json:"height,omitempty"`
	Duration           int64                                        `protobuf:"varint,7,opt,name=duration,proto3" json:"duration,omitempty"`
	Rate               types.Coin                                   `protobuf:"bytes,8,opt,name=rate,proto3" json:"rate"`
	Deposit            cosmossdk_io_math.Int                        `protobuf:"bytes,9,opt,name=deposit,proto3,customtype=cosmossdk.io/math.Int" json:"deposit"`
	Paid               cosmossdk_io_math.Int                        `protobuf:"bytes,10,opt,name=paid,proto3,customtype=cosmossdk.io/math.Int" json:"paid"`
	Nonce              int64                                        `protobuf:"varint,11,opt,name=nonce,proto3" json:"nonce,omitempty"`
	SettlementHeight   int64                                        `protobuf:"varint,12,opt,name=settlement_height,json=settlementHeight,proto3" json:"settlement_height,omitempty"`
	Id                 uint64                                       `protobuf:"varint,13,opt,name=id,proto3" json:"id,omitempty"`
	SettlementDuration int64                                        `protobuf:"varint,14,opt,name=settlement_duration,json=settlementDuration,proto3" json:"settlement_duration,omitempty"`
	Authorization      ContractAuthorization                        `protobuf:"varint,15,opt,name=authorization,proto3,enum=arkeo.arkeo.ContractAuthorization" json:"authorization,omitempty"`
	QueriesPerMinute   int64                                        `protobuf:"varint,16,opt,name=queries_per_minute,json=queriesPerMinute,proto3" json:"queries_per_minute,omitempty"`
}

func (m *Contract) Reset()         { *m = Contract{} }
func (m *Contract) String() string { return proto.CompactTextString(m) }
func (*Contract) ProtoMessage()    {}
func (*Contract) Descriptor() ([]byte, []int) {
	return fileDescriptor_f833050061122841, []int{1}
}
func (m *Contract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Contract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Contract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Contract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Contract.Merge(m, src)
}
func (m *Contract) XXX_Size() int {
	return m.Size()
}
func (m *Contract) XXX_DiscardUnknown() {
	xxx_messageInfo_Contract.DiscardUnknown(m)
}

var xxx_messageInfo_Contract proto.InternalMessageInfo

func (m *Contract) GetProvider() github_com_arkeonetwork_arkeo_common.PubKey {
	if m != nil {
		return m.Provider
	}
	return nil
}

func (m *Contract) GetService() github_com_arkeonetwork_arkeo_common.Service {
	if m != nil {
		return m.Service
	}
	return 0
}

func (m *Contract) GetClient() github_com_arkeonetwork_arkeo_common.PubKey {
	if m != nil {
		return m.Client
	}
	return nil
}

func (m *Contract) GetDelegate() github_com_arkeonetwork_arkeo_common.PubKey {
	if m != nil {
		return m.Delegate
	}
	return nil
}

func (m *Contract) GetType() ContractType {
	if m != nil {
		return m.Type
	}
	return ContractType_SUBSCRIPTION
}

func (m *Contract) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Contract) GetDuration() int64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Contract) GetRate() types.Coin {
	if m != nil {
		return m.Rate
	}
	return types.Coin{}
}

func (m *Contract) GetNonce() int64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *Contract) GetSettlementHeight() int64 {
	if m != nil {
		return m.SettlementHeight
	}
	return 0
}

func (m *Contract) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Contract) GetSettlementDuration() int64 {
	if m != nil {
		return m.SettlementDuration
	}
	return 0
}

func (m *Contract) GetAuthorization() ContractAuthorization {
	if m != nil {
		return m.Authorization
	}
	return ContractAuthorization_STRICT
}

func (m *Contract) GetQueriesPerMinute() int64 {
	if m != nil {
		return m.QueriesPerMinute
	}
	return 0
}

// ContractSet defines a set of contracts.
type ContractSet struct {
	ContractIds []uint64 `protobuf:"varint,1,rep,packed,name=contract_ids,json=contractIds,proto3" json:"contract_ids,omitempty"`
}

func (m *ContractSet) Reset()         { *m = ContractSet{} }
func (m *ContractSet) String() string { return proto.CompactTextString(m) }
func (*ContractSet) ProtoMessage()    {}
func (*ContractSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_f833050061122841, []int{2}
}
func (m *ContractSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractSet.Merge(m, src)
}
func (m *ContractSet) XXX_Size() int {
	return m.Size()
}
func (m *ContractSet) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractSet.DiscardUnknown(m)
}

var xxx_messageInfo_ContractSet proto.InternalMessageInfo

func (m *ContractSet) GetContractIds() []uint64 {
	if m != nil {
		return m.ContractIds
	}
	return nil
}

// ContractExpirationSet defines a set of contract expirations.
type ContractExpirationSet struct {
	Height      int64        `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	ContractSet *ContractSet `protobuf:"bytes,2,opt,name=contract_set,json=contractSet,proto3" json:"contract_set,omitempty"`
}

func (m *ContractExpirationSet) Reset()         { *m = ContractExpirationSet{} }
func (m *ContractExpirationSet) String() string { return proto.CompactTextString(m) }
func (*ContractExpirationSet) ProtoMessage()    {}
func (*ContractExpirationSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_f833050061122841, []int{3}
}
func (m *ContractExpirationSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractExpirationSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractExpirationSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractExpirationSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractExpirationSet.Merge(m, src)
}
func (m *ContractExpirationSet) XXX_Size() int {
	return m.Size()
}
func (m *ContractExpirationSet) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractExpirationSet.DiscardUnknown(m)
}

var xxx_messageInfo_ContractExpirationSet proto.InternalMessageInfo

func (m *ContractExpirationSet) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *ContractExpirationSet) GetContractSet() *ContractSet {
	if m != nil {
		return m.ContractSet
	}
	return nil
}

// UserContractSet defines a set of contracts belonging to a user.
type UserContractSet struct {
	User        github_com_arkeonetwork_arkeo_common.PubKey `protobuf:"bytes,1,opt,name=user,proto3,casttype=github.com/arkeonetwork/arkeo/common.PubKey" json:"user,omitempty"`
	ContractSet *ContractSet                                `protobuf:"bytes,2,opt,name=contract_set,json=contractSet,proto3" json:"contract_set,omitempty"`
}

func (m *UserContractSet) Reset()         { *m = UserContractSet{} }
func (m *UserContractSet) String() string { return proto.CompactTextString(m) }
func (*UserContractSet) ProtoMessage()    {}
func (*UserContractSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_f833050061122841, []int{4}
}
func (m *UserContractSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserContractSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserContractSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserContractSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserContractSet.Merge(m, src)
}
func (m *UserContractSet) XXX_Size() int {
	return m.Size()
}
func (m *UserContractSet) XXX_DiscardUnknown() {
	xxx_messageInfo_UserContractSet.DiscardUnknown(m)
}

var xxx_messageInfo_UserContractSet proto.InternalMessageInfo

func (m *UserContractSet) GetUser() github_com_arkeonetwork_arkeo_common.PubKey {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UserContractSet) GetContractSet() *ContractSet {
	if m != nil {
		return m.ContractSet
	}
	return nil
}

// Service captures the metadata for a dynamically-registered provider service.
type Service struct {
	// Globally-unique numeric identifier for this service.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Canonical, lowercase name (e.g., "arkeo-mainnet-rest").
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Optional human-friendly description.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Optional type/classification (e.g., "rpc", "rest", "indexer").
	ServiceType string `protobuf:"bytes,4,opt,name=service_type,json=serviceType,proto3" json:"service_type,omitempty"`
}

func (m *Service) Reset()         { *m = Service{} }
func (m *Service) String() string { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()    {}
func (*Service) Descriptor() ([]byte, []int) {
	return fileDescriptor_f833050061122841, []int{5}
}
func (m *Service) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Service) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Service.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Service) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Service.Merge(m, src)
}
func (m *Service) XXX_Size() int {
	return m.Size()
}
func (m *Service) XXX_DiscardUnknown() {
	xxx_messageInfo_Service.DiscardUnknown(m)
}

var xxx_messageInfo_Service proto.InternalMessageInfo

func (m *Service) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Service) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Service) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Service) GetServiceType() string {
	if m != nil {
		return m.ServiceType
	}
	return ""
}

func init() {
	proto.RegisterEnum("arkeo.arkeo.ProviderStatus", ProviderStatus_name, ProviderStatus_value)
	proto.RegisterEnum("arkeo.arkeo.ContractType", ContractType_name, ContractType_value)
	proto.RegisterEnum("arkeo.arkeo.ContractAuthorization", ContractAuthorization_name, ContractAuthorization_value)
	proto.RegisterType((*Provider)(nil), "arkeo.arkeo.Provider")
	proto.RegisterType((*Contract)(nil), "arkeo.arkeo.Contract")
	proto.RegisterType((*ContractSet)(nil), "arkeo.arkeo.ContractSet")
	proto.RegisterType((*ContractExpirationSet)(nil), "arkeo.arkeo.ContractExpirationSet")
	proto.RegisterType((*UserContractSet)(nil), "arkeo.arkeo.UserContractSet")
	proto.RegisterType((*Service)(nil), "arkeo.arkeo.Service")
}

func init() { proto.RegisterFile("arkeo/arkeo/keeper.proto", fileDescriptor_f833050061122841) }

var fileDescriptor_f833050061122841 = []byte{
	// 983 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x41, 0x4f, 0xe3, 0x46,
	0x14, 0x8e, 0xc1, 0x24, 0xe1, 0x25, 0x64, 0xcd, 0xec, 0x52, 0x19, 0x2a, 0x85, 0x34, 0xd2, 0x4a,
	0x29, 0x2c, 0x4e, 0x17, 0x7a, 0xeb, 0xa1, 0x22, 0x94, 0x85, 0x94, 0x2d, 0x89, 0x1c, 0x38, 0xd0,
	0x8b, 0x35, 0xb1, 0x47, 0x61, 0x04, 0xf6, 0xb8, 0x9e, 0x31, 0x25, 0xfd, 0x15, 0x95, 0xfa, 0x57,
	0xda, 0xff, 0xb0, 0xc7, 0x55, 0xa5, 0x4a, 0x55, 0x0f, 0xa8, 0x82, 0x7f, 0xb1, 0xa7, 0xca, 0x33,
	0xe3, 0x10, 0x5a, 0x56, 0xa5, 0x74, 0x2f, 0xb6, 0xe7, 0xbd, 0xf7, 0x7d, 0x99, 0x79, 0xef, 0x7b,
	0x6f, 0x02, 0x36, 0x4e, 0xce, 0x08, 0x6b, 0xab, 0xe7, 0x19, 0x21, 0x31, 0x49, 0x9c, 0x38, 0x61,
	0x82, 0xa1, 0x8a, 0xb4, 0x39, 0xf2, 0xb9, 0xf2, 0x6c, 0xc4, 0x46, 0x4c, 0xda, 0xdb, 0xd9, 0x97,
	0x0a, 0x59, 0x59, 0xf6, 0x19, 0x0f, 0x19, 0xf7, 0x94, 0x43, 0x2d, 0xb4, 0xab, 0xae, 0x56, 0xed,
	0x21, 0xe6, 0xa4, 0x7d, 0xf1, 0x72, 0x48, 0x04, 0x7e, 0xd9, 0xf6, 0x19, 0x8d, 0x94, 0xbf, 0xf9,
	0xcb, 0x1c, 0x94, 0xfb, 0x09, 0xbb, 0xa0, 0x01, 0x49, 0xd0, 0x3e, 0x94, 0xe2, 0x74, 0xe8, 0x9d,
	0x91, 0xb1, 0x6d, 0x34, 0x8c, 0x56, 0xb5, 0xd3, 0x7e, 0x77, 0xb5, 0xba, 0x3e, 0xa2, 0xe2, 0x34,
	0x1d, 0x3a, 0x3e, 0x0b, 0xd5, 0xf6, 0x22, 0x22, 0xbe, 0x67, 0xc9, 0x99, 0xde, 0xab, 0xcf, 0xc2,
	0x90, 0x45, 0x4e, 0x3f, 0x1d, 0x1e, 0x90, 0xb1, 0x5b, 0x8c, 0xe5, 0x1b, 0x7d, 0x0d, 0x25, 0x4e,
	0x92, 0x0b, 0xea, 0x13, 0x7b, 0xa6, 0x61, 0xb4, 0xe6, 0x3a, 0x9f, 0xbd, 0xbb, 0x5a, 0x7d, 0xf1,
	0x20, 0xa6, 0x81, 0xc2, 0xb9, 0x39, 0x01, 0xfa, 0x04, 0xaa, 0x21, 0x11, 0x38, 0xc0, 0x02, 0x7b,
	0x69, 0x42, 0xed, 0xd9, 0x86, 0xd1, 0x9a, 0x77, 0x2b, 0xb9, 0xed, 0x38, 0xa1, 0xe8, 0x39, 0xd4,
	0x26, 0x21, 0x11, 0x8b, 0x7c, 0x62, 0x9b, 0x0d, 0xa3, 0x65, 0xba, 0x0b, 0xb9, 0xf5, 0x30, 0x33,
	0xa2, 0x2d, 0x28, 0x72, 0x81, 0x45, 0xca, 0xed, 0xb9, 0x86, 0xd1, 0xaa, 0x6d, 0x7e, 0xec, 0x4c,
	0xe5, 0xd6, 0xc9, 0xd3, 0x30, 0x90, 0x21, 0xae, 0x0e, 0x45, 0x9b, 0xb0, 0x14, 0xd2, 0xc8, 0xf3,
	0x59, 0x24, 0x12, 0xec, 0x0b, 0x2f, 0x48, 0x13, 0x2c, 0x28, 0x8b, 0xec, 0x62, 0xc3, 0x68, 0xcd,
	0xba, 0x4f, 0x43, 0x1a, 0xed, 0x68, 0xdf, 0x57, 0xda, 0x25, 0x31, 0xf8, 0xf2, 0x1e, 0x4c, 0x49,
	0x63, 0xf0, 0xe5, 0x3f, 0x30, 0xaf, 0x61, 0x91, 0xa7, 0x43, 0xee, 0x27, 0x34, 0xce, 0xd6, 0x5e,
	0x82, 0x05, 0xb1, 0xcb, 0x8d, 0xd9, 0x56, 0x65, 0x73, 0xd9, 0xd1, 0x35, 0xcd, 0xaa, 0xe8, 0xe8,
	0x2a, 0x3a, 0x3b, 0x8c, 0x46, 0x1d, 0xf3, 0xcd, 0xd5, 0x6a, 0xc1, 0xb5, 0xa6, 0x91, 0x2e, 0x16,
	0x04, 0x1d, 0x00, 0x8a, 0xf1, 0xd8, 0xc3, 0xdc, 0x1b, 0xb3, 0xd4, 0x1b, 0x31, 0x45, 0x37, 0xff,
	0x30, 0xba, 0x5a, 0x8c, 0xc7, 0xdb, 0xfc, 0x84, 0xa5, 0x7b, 0x4c, 0x92, 0x7d, 0x09, 0xe6, 0x90,
	0x45, 0x81, 0x0d, 0x59, 0xe6, 0x3b, 0xeb, 0x59, 0xcc, 0x1f, 0x57, 0xab, 0x4b, 0x8a, 0x85, 0x07,
	0x67, 0x0e, 0x65, 0xed, 0x10, 0x8b, 0x53, 0xa7, 0x1b, 0x89, 0x5f, 0x7f, 0xde, 0x00, 0x4d, 0xdf,
	0x8d, 0x84, 0x2b, 0x81, 0x68, 0x15, 0x2a, 0xe7, 0x98, 0x0b, 0x2f, 0x8d, 0x83, 0x6c, 0x1b, 0x15,
	0x99, 0x05, 0xc8, 0x4c, 0xc7, 0xd2, 0x82, 0xda, 0xf0, 0x94, 0x13, 0x21, 0xce, 0x49, 0x48, 0xa2,
	0xa9, 0x74, 0x55, 0x65, 0x20, 0xba, 0x75, 0xe5, 0xd9, 0x6a, 0xfe, 0x56, 0x84, 0x72, 0x9e, 0x42,
	0x74, 0x00, 0xe5, 0x58, 0x17, 0xef, 0xb1, 0xc2, 0x9d, 0x10, 0x7c, 0x50, 0xe9, 0xee, 0x41, 0xd1,
	0x3f, 0xa7, 0x24, 0x12, 0x52, 0xb4, 0x8f, 0xe9, 0x27, 0x05, 0xcf, 0x4e, 0x18, 0x90, 0x73, 0x32,
	0xca, 0xb2, 0x67, 0x3e, 0xf2, 0x84, 0x39, 0x01, 0xda, 0x00, 0x53, 0x8c, 0x63, 0xa2, 0x9b, 0x60,
	0xf9, 0x4e, 0x13, 0xe4, 0x39, 0x3d, 0x1a, 0xc7, 0xc4, 0x95, 0x61, 0xe8, 0x23, 0x28, 0x9e, 0x12,
	0x3a, 0x3a, 0x15, 0x5a, 0xf1, 0x7a, 0x85, 0x56, 0xa0, 0xfc, 0x37, 0x5d, 0x4f, 0xd6, 0x68, 0x0b,
	0x4c, 0xad, 0x5f, 0xe3, 0x21, 0x82, 0x93, 0xc1, 0x68, 0x17, 0x4a, 0x01, 0x89, 0x19, 0xa7, 0xc2,
	0x9e, 0xff, 0xef, 0x4a, 0xcb, 0xb1, 0x99, 0x5a, 0x63, 0x4c, 0x1f, 0xa7, 0xd6, 0x0c, 0x88, 0x9e,
	0xc1, 0x9c, 0x1a, 0x22, 0x4a, 0xa7, 0x6a, 0x81, 0xd6, 0x61, 0x71, 0x4a, 0xa2, 0x3a, 0x23, 0x4a,
	0xa0, 0xd6, 0xad, 0x63, 0x5f, 0xe5, 0xa6, 0x06, 0x33, 0x34, 0xb0, 0x17, 0xe4, 0x10, 0x9a, 0xa1,
	0xc1, 0xfb, 0xf4, 0x5d, 0x7b, 0x9f, 0xbe, 0xd1, 0x3e, 0x2c, 0xe0, 0x54, 0x9c, 0xb2, 0x84, 0xfe,
	0xa0, 0x42, 0x9f, 0xc8, 0x62, 0x35, 0xef, 0x2d, 0xd6, 0xf6, 0x74, 0xa4, 0x7b, 0x17, 0x88, 0x5e,
	0x00, 0xfa, 0x2e, 0x25, 0x09, 0x25, 0xdc, 0x8b, 0x49, 0xe2, 0x85, 0x34, 0x4a, 0x05, 0xb1, 0x2d,
	0xb5, 0x71, 0xed, 0xe9, 0x93, 0xe4, 0x1b, 0x69, 0x6f, 0x7e, 0x0e, 0x95, 0x9c, 0x75, 0x40, 0x04,
	0x7a, 0x0e, 0xd5, 0xc9, 0x10, 0xa3, 0x01, 0xb7, 0x8d, 0xc6, 0x6c, 0xcb, 0xec, 0xcc, 0x58, 0x86,
	0x5b, 0xc9, 0xed, 0xdd, 0x80, 0x37, 0xcf, 0x61, 0x29, 0x47, 0xed, 0x5e, 0xc6, 0x54, 0x9d, 0x21,
	0xc3, 0xdf, 0x6a, 0xc7, 0xb8, 0xa3, 0x9d, 0x2f, 0xa6, 0x78, 0x39, 0x11, 0xb2, 0xd3, 0x2a, 0x9b,
	0xf6, 0xbd, 0xa7, 0x1b, 0x10, 0x71, 0xfb, 0x6b, 0x03, 0x22, 0x9a, 0x3f, 0x19, 0xf0, 0xe4, 0x98,
	0x93, 0x64, 0x7a, 0xa3, 0x3b, 0x60, 0xa6, 0xfc, 0xf1, 0xed, 0x2f, 0xc1, 0xff, 0x6f, 0x57, 0x09,
	0x94, 0x74, 0xff, 0xeb, 0xea, 0x1b, 0x93, 0xea, 0x23, 0x30, 0x23, 0x1c, 0xaa, 0x79, 0x32, 0xef,
	0xca, 0x6f, 0xd4, 0x80, 0x4a, 0x40, 0x26, 0x33, 0x3b, 0xbf, 0xd4, 0xa6, 0x4c, 0xd9, 0xbd, 0xa7,
	0xe7, 0x88, 0x27, 0xdb, 0xd5, 0x54, 0x21, 0xda, 0x96, 0x35, 0xe8, 0xda, 0xa7, 0x50, 0xbb, 0x7b,
	0x6b, 0xa1, 0x0a, 0x94, 0x7a, 0xaf, 0x5e, 0xbd, 0xee, 0x1e, 0xee, 0x5a, 0x05, 0x04, 0x50, 0xec,
	0x1d, 0xca, 0x6f, 0x63, 0x6d, 0x0b, 0xaa, 0xd3, 0xbd, 0x8d, 0x2c, 0xa8, 0x0e, 0x8e, 0x3b, 0x83,
	0x1d, 0xb7, 0xdb, 0x3f, 0xea, 0xf6, 0x0e, 0xad, 0x02, 0x5a, 0x84, 0x85, 0xfe, 0xf6, 0x89, 0xb7,
	0x3d, 0xf0, 0x4e, 0x7a, 0xc7, 0xde, 0x5e, 0xcf, 0x32, 0xd6, 0x36, 0x6e, 0xeb, 0x7a, 0x47, 0x63,
	0x19, 0xf3, 0xe0, 0xc8, 0xed, 0xee, 0x1c, 0x59, 0x05, 0x54, 0x06, 0xb3, 0xd7, 0xdf, 0x3d, 0xb4,
	0x8c, 0xce, 0xee, 0x9b, 0xeb, 0xba, 0xf1, 0xf6, 0xba, 0x6e, 0xfc, 0x79, 0x5d, 0x37, 0x7e, 0xbc,
	0xa9, 0x17, 0xde, 0xde, 0xd4, 0x0b, 0xbf, 0xdf, 0xd4, 0x0b, 0xdf, 0xfe, 0x4b, 0x31, 0x2e, 0xf5,
	0x3b, 0x3b, 0x27, 0x1f, 0x16, 0xe5, 0x5f, 0x93, 0xad, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0xb7,
	0x1c, 0x84, 0x8b, 0x14, 0x09, 0x00, 0x00,
}

func (m *Provider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Provider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Provider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SettlementDuration != 0 {
		i = encodeVarintKeeper(dAtA, i, uint64(m.SettlementDuration))
		i--
		dAtA[i] = 0x60
	}
	if m.LastUpdate != 0 {
		i = encodeVarintKeeper(dAtA, i, uint64(m.LastUpdate))
		i--
		dAtA[i] = 0x58
	}
	{
		size := m.Bond.Size()
		i -= size
		if _, err := m.Bond.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintKeeper(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if len(m.PayAsYouGoRate) > 0 {
		for iNdEx := len(m.PayAsYouGoRate) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PayAsYouGoRate[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintKeeper(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.SubscriptionRate) > 0 {
		for iNdEx := len(m.SubscriptionRate) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SubscriptionRate[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintKeeper(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.MaxContractDuration != 0 {
		i = encodeVarintKeeper(dAtA, i, uint64(m.MaxContractDuration))
		i--
		dAtA[i] = 0x38
	}
	if m.MinContractDuration != 0 {
		i = encodeVarintKeeper(dAtA, i, uint64(m.MinContractDuration))
		i--
		dAtA[i] = 0x30
	}
	if m.Status != 0 {
		i = encodeVarintKeeper(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if m.MetadataNonce != 0 {
		i = encodeVarintKeeper(dAtA, i, uint64(m.MetadataNonce))
		i--
		dAtA[i] = 0x20
	}
	if len(m.MetadataUri) > 0 {
		i -= len(m.MetadataUri)
		copy(dAtA[i:], m.MetadataUri)
		i = encodeVarintKeeper(dAtA, i, uint64(len(m.MetadataUri)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Service != 0 {
		i = encodeVarintKeeper(dAtA, i, uint64(m.Service))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintKeeper(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Contract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Contract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Contract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QueriesPerMinute != 0 {
		i = encodeVarintKeeper(dAtA, i, uint64(m.QueriesPerMinute))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Authorization != 0 {
		i = encodeVarintKeeper(dAtA, i, uint64(m.Authorization))
		i--
		dAtA[i] = 0x78
	}
	if m.SettlementDuration != 0 {
		i = encodeVarintKeeper(dAtA, i, uint64(m.SettlementDuration))
		i--
		dAtA[i] = 0x70
	}
	if m.Id != 0 {
		i = encodeVarintKeeper(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x68
	}
	if m.SettlementHeight != 0 {
		i = encodeVarintKeeper(dAtA, i, uint64(m.SettlementHeight))
		i--
		dAtA[i] = 0x60
	}
	if m.Nonce != 0 {
		i = encodeVarintKeeper(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x58
	}
	{
		size := m.Paid.Size()
		i -= size
		if _, err := m.Paid.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintKeeper(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size := m.Deposit.Size()
		i -= size
		if _, err := m.Deposit.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintKeeper(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.Rate.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintKeeper(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.Duration != 0 {
		i = encodeVarintKeeper(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x38
	}
	if m.Height != 0 {
		i = encodeVarintKeeper(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x30
	}
	if m.Type != 0 {
		i = encodeVarintKeeper(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Delegate) > 0 {
		i -= len(m.Delegate)
		copy(dAtA[i:], m.Delegate)
		i = encodeVarintKeeper(dAtA, i, uint64(len(m.Delegate)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Client) > 0 {
		i -= len(m.Client)
		copy(dAtA[i:], m.Client)
		i = encodeVarintKeeper(dAtA, i, uint64(len(m.Client)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Service != 0 {
		i = encodeVarintKeeper(dAtA, i, uint64(m.Service))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintKeeper(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContractIds) > 0 {
		dAtA3 := make([]byte, len(m.ContractIds)*10)
		var j2 int
		for _, num := range m.ContractIds {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintKeeper(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractExpirationSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractExpirationSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractExpirationSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContractSet != nil {
		{
			size, err := m.ContractSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKeeper(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Height != 0 {
		i = encodeVarintKeeper(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserContractSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserContractSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserContractSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContractSet != nil {
		{
			size, err := m.ContractSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintKeeper(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintKeeper(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Service) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Service) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Service) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ServiceType) > 0 {
		i -= len(m.ServiceType)
		copy(dAtA[i:], m.ServiceType)
		i = encodeVarintKeeper(dAtA, i, uint64(len(m.ServiceType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintKeeper(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintKeeper(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintKeeper(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintKeeper(dAtA []byte, offset int, v uint64) int {
	offset -= sovKeeper(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Provider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovKeeper(uint64(l))
	}
	if m.Service != 0 {
		n += 1 + sovKeeper(uint64(m.Service))
	}
	l = len(m.MetadataUri)
	if l > 0 {
		n += 1 + l + sovKeeper(uint64(l))
	}
	if m.MetadataNonce != 0 {
		n += 1 + sovKeeper(uint64(m.MetadataNonce))
	}
	if m.Status != 0 {
		n += 1 + sovKeeper(uint64(m.Status))
	}
	if m.MinContractDuration != 0 {
		n += 1 + sovKeeper(uint64(m.MinContractDuration))
	}
	if m.MaxContractDuration != 0 {
		n += 1 + sovKeeper(uint64(m.MaxContractDuration))
	}
	if len(m.SubscriptionRate) > 0 {
		for _, e := range m.SubscriptionRate {
			l = e.Size()
			n += 1 + l + sovKeeper(uint64(l))
		}
	}
	if len(m.PayAsYouGoRate) > 0 {
		for _, e := range m.PayAsYouGoRate {
			l = e.Size()
			n += 1 + l + sovKeeper(uint64(l))
		}
	}
	l = m.Bond.Size()
	n += 1 + l + sovKeeper(uint64(l))
	if m.LastUpdate != 0 {
		n += 1 + sovKeeper(uint64(m.LastUpdate))
	}
	if m.SettlementDuration != 0 {
		n += 1 + sovKeeper(uint64(m.SettlementDuration))
	}
	return n
}

func (m *Contract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovKeeper(uint64(l))
	}
	if m.Service != 0 {
		n += 1 + sovKeeper(uint64(m.Service))
	}
	l = len(m.Client)
	if l > 0 {
		n += 1 + l + sovKeeper(uint64(l))
	}
	l = len(m.Delegate)
	if l > 0 {
		n += 1 + l + sovKeeper(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovKeeper(uint64(m.Type))
	}
	if m.Height != 0 {
		n += 1 + sovKeeper(uint64(m.Height))
	}
	if m.Duration != 0 {
		n += 1 + sovKeeper(uint64(m.Duration))
	}
	l = m.Rate.Size()
	n += 1 + l + sovKeeper(uint64(l))
	l = m.Deposit.Size()
	n += 1 + l + sovKeeper(uint64(l))
	l = m.Paid.Size()
	n += 1 + l + sovKeeper(uint64(l))
	if m.Nonce != 0 {
		n += 1 + sovKeeper(uint64(m.Nonce))
	}
	if m.SettlementHeight != 0 {
		n += 1 + sovKeeper(uint64(m.SettlementHeight))
	}
	if m.Id != 0 {
		n += 1 + sovKeeper(uint64(m.Id))
	}
	if m.SettlementDuration != 0 {
		n += 1 + sovKeeper(uint64(m.SettlementDuration))
	}
	if m.Authorization != 0 {
		n += 1 + sovKeeper(uint64(m.Authorization))
	}
	if m.QueriesPerMinute != 0 {
		n += 2 + sovKeeper(uint64(m.QueriesPerMinute))
	}
	return n
}

func (m *ContractSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ContractIds) > 0 {
		l = 0
		for _, e := range m.ContractIds {
			l += sovKeeper(uint64(e))
		}
		n += 1 + sovKeeper(uint64(l)) + l
	}
	return n
}

func (m *ContractExpirationSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovKeeper(uint64(m.Height))
	}
	if m.ContractSet != nil {
		l = m.ContractSet.Size()
		n += 1 + l + sovKeeper(uint64(l))
	}
	return n
}

func (m *UserContractSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovKeeper(uint64(l))
	}
	if m.ContractSet != nil {
		l = m.ContractSet.Size()
		n += 1 + l + sovKeeper(uint64(l))
	}
	return n
}

func (m *Service) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovKeeper(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovKeeper(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovKeeper(uint64(l))
	}
	l = len(m.ServiceType)
	if l > 0 {
		n += 1 + l + sovKeeper(uint64(l))
	}
	return n
}

func sovKeeper(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozKeeper(x uint64) (n int) {
	return sovKeeper(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Provider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeeper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Provider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Provider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKeeper
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKeeper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			m.Service = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Service |= github_com_arkeonetwork_arkeo_common.Service(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeeper
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeeper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataNonce", wireType)
			}
			m.MetadataNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetadataNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ProviderStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinContractDuration", wireType)
			}
			m.MinContractDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinContractDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxContractDuration", wireType)
			}
			m.MaxContractDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxContractDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionRate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeeper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKeeper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionRate = append(m.SubscriptionRate, types.Coin{})
			if err := m.SubscriptionRate[len(m.SubscriptionRate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayAsYouGoRate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeeper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKeeper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayAsYouGoRate = append(m.PayAsYouGoRate, types.Coin{})
			if err := m.PayAsYouGoRate[len(m.PayAsYouGoRate)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bond", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeeper
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeeper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Bond.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
			}
			m.LastUpdate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementDuration", wireType)
			}
			m.SettlementDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKeeper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthKeeper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Contract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeeper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKeeper
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKeeper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = append(m.Provider[:0], dAtA[iNdEx:postIndex]...)
			if m.Provider == nil {
				m.Provider = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			m.Service = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Service |= github_com_arkeonetwork_arkeo_common.Service(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Client", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKeeper
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKeeper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Client = append(m.Client[:0], dAtA[iNdEx:postIndex]...)
			if m.Client == nil {
				m.Client = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegate", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKeeper
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKeeper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegate = append(m.Delegate[:0], dAtA[iNdEx:postIndex]...)
			if m.Delegate == nil {
				m.Delegate = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ContractType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeeper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKeeper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeeper
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeeper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Deposit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeeper
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeeper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Paid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementHeight", wireType)
			}
			m.SettlementHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementDuration", wireType)
			}
			m.SettlementDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authorization", wireType)
			}
			m.Authorization = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Authorization |= ContractAuthorization(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueriesPerMinute", wireType)
			}
			m.QueriesPerMinute = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueriesPerMinute |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKeeper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthKeeper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeeper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKeeper
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ContractIds = append(m.ContractIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowKeeper
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthKeeper
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthKeeper
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ContractIds) == 0 {
					m.ContractIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowKeeper
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ContractIds = append(m.ContractIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipKeeper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthKeeper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractExpirationSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeeper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractExpirationSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractExpirationSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeeper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKeeper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContractSet == nil {
				m.ContractSet = &ContractSet{}
			}
			if err := m.ContractSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeeper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthKeeper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserContractSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeeper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserContractSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserContractSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthKeeper
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthKeeper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = append(m.User[:0], dAtA[iNdEx:postIndex]...)
			if m.User == nil {
				m.User = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthKeeper
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthKeeper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContractSet == nil {
				m.ContractSet = &ContractSet{}
			}
			if err := m.ContractSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeeper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthKeeper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Service) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowKeeper
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeeper
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeeper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeeper
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeeper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthKeeper
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthKeeper
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipKeeper(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthKeeper
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipKeeper(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowKeeper
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowKeeper
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthKeeper
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupKeeper
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthKeeper
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthKeeper        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowKeeper          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupKeeper = fmt.Errorf("proto: unexpected end of group")
)
